// Generated by CoffeeScript 1.6.3
(function() {
  var TaskGroup, eachr,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  TaskGroup = require('taskgroup').TaskGroup;

  eachr = require('eachr');

  module.exports = function(BasePlugin) {
    var TumblrPlugin, _ref;
    return TumblrPlugin = (function(_super) {
      __extends(TumblrPlugin, _super);

      function TumblrPlugin() {
        _ref = TumblrPlugin.__super__.constructor.apply(this, arguments);
        return _ref;
      }

      TumblrPlugin.prototype.name = 'tumblr';

      TumblrPlugin.prototype.config = {
        blog: process.env.TUMBLR_BLOG,
        apiKey: process.env.TUMBLR_API_KEY,
        relativeDirPath: "tumblr",
        extension: ".json",
        injectDocumentHelper: null,
        collectionName: "tumblr"
      };

      TumblrPlugin.prototype.extendCollections = function() {
        var config, docpad, tagsCollection;
        config = this.getConfig();
        docpad = this.docpad;
        if (config.collectionName) {
          tagsCollection = docpad.getFiles({
            relativeDirPath: {
              $startsWith: config.relativeDirPath
            }
          }, [
            {
              title: 1
            }
          ]);
          docpad.setCollection(config.collectionName, tagsCollection);
        }
        return this;
      };

      TumblrPlugin.prototype.fetchTumblrData = function(opts, next) {
        var apiKey, blog, config, err, feedr, tumblrPosts, tumblrUrl;
        if (opts == null) {
          opts = {};
        }
        config = this.getConfig();
        feedr = this.feedr != null ? this.feedr : this.feedr = new (require('feedr').Feedr);
        if (!config.blog || !config.apiKey) {
          err = new Error('Tumblr plugin is not configured correctly');
          return next(err);
        }
        blog = config.blog, apiKey = config.apiKey;
        if (blog.indexOf('.') === -1) {
          blog = blog + '.tumblr.com';
        }
        tumblrUrl = "http://api.tumblr.com/v2/blog/" + blog + "/posts?api_key=" + (escape(apiKey));
        tumblrPosts = [];
        feedr.readFeed(tumblrUrl, {
          parse: 'json'
        }, function(err, feedData) {
          var feeds, offset, tumblrPost, _i, _j, _len, _ref1, _ref2, _ref3;
          if (err) {
            return next(err);
          }
          if (!((_ref1 = feedData.response) != null ? _ref1.posts : void 0)) {
            err = new Error("Tumblr post data was empty, here's the result: " + JSON.stringify(feedData));
            return next(err);
          }
          _ref2 = feedData.response.posts || [];
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            tumblrPost = _ref2[_i];
            tumblrPosts.push(tumblrPost);
          }
          feeds = [];
          for (offset = _j = 20, _ref3 = feedData.response.blog.posts; _j < _ref3; offset = _j += 20) {
            feeds.push("" + tumblrUrl + "&offset=" + offset);
          }
          return feedr.readFeeds(feeds, {
            parse: 'json'
          }, function(err, feedsData) {
            var _k, _l, _len1, _len2, _ref4, _ref5;
            if (err) {
              return next(err);
            }
            for (_k = 0, _len1 = feedsData.length; _k < _len1; _k++) {
              feedData = feedsData[_k];
              if (!((_ref4 = feedData.response) != null ? _ref4.posts : void 0)) {
                err = new Error("Tumblr post data was empty, here's the result: " + JSON.stringify(feedData));
                return next(err);
              }
              _ref5 = feedData.response.posts || [];
              for (_l = 0, _len2 = _ref5.length; _l < _len2; _l++) {
                tumblrPost = _ref5[_l];
                tumblrPosts.push(tumblrPost);
              }
            }
            return next(null, tumblrPosts);
          });
        });
        return this;
      };

      TumblrPlugin.prototype.createTumblrPost = function(tumblrPost, next) {
        var config, docpad, document, documentAttributes, documentTime, plugin, tumblrPostDate, tumblrPostId, tumblrPostMtime, _ref1;
        plugin = this;
        docpad = this.docpad;
        config = this.getConfig();
        tumblrPostId = parseInt(tumblrPost.id, 10);
        tumblrPostMtime = new Date(tumblrPost.date);
        tumblrPostDate = new Date(tumblrPost.date);
        document = docpad.getFile({
          tumblrId: tumblrPostId
        });
        documentTime = (document != null ? document.get('mtime') : void 0) || null;
        if (documentTime && documentTime.toString() === tumblrPostMtime.toString()) {
          return next(null, null);
        }
        documentAttributes = {
          data: JSON.stringify(tumblrPost, null, '\t'),
          meta: {
            tumblrId: tumblrPostId,
            tumblrType: tumblrPost.type,
            tumblr: tumblrPost,
            title: (tumblrPost.title || tumblrPost.track_name || tumblrPost.text || tumblrPost.caption || '').replace(/<(?:.|\n)*?>/gm, ''),
            date: tumblrPostDate,
            mtime: tumblrPostMtime,
            tags: (tumblrPost.tags || []).concat([tumblrPost.type]),
            relativePath: "" + config.relativeDirPath + "/" + tumblrPost.type + "/" + tumblrPost.id + config.extension
          }
        };
        if (document != null) {
          document.set(documentAttributes);
        } else {
          document = docpad.createDocument(documentAttributes);
        }
        if ((_ref1 = config.injectDocumentHelper) != null) {
          _ref1.call(plugin, document);
        }
        document.action('load', function(err) {
          if (err) {
            return next(err, document);
          }
          (typeof docpad.addModel === "function" ? docpad.addModel(document) : void 0) || docpad.getDatabase().add(document);
          return next(null, document);
        });
        return document;
      };

      TumblrPlugin.prototype.populateCollections = function(opts, next) {
        var docpad, imported, plugin;
        plugin = this;
        docpad = this.docpad;
        imported = 0;
        docpad.log('info', "Importing Tumblr posts...");
        this.fetchTumblrData(null, function(err, tumblrPosts) {
          var tasks;
          if (err) {
            return next(err);
          }
          tasks = new TaskGroup({
            concurrency: 0
          }).once('complete', function(err) {
            if (err) {
              return next(err);
            }
            docpad.log('info', "Imported " + imported + "/" + tumblrPosts.length + " Tumblr posts...");
            return next();
          });
          eachr(tumblrPosts, function(tumblrPost, i) {
            return tasks.addTask(function(complete) {
              return plugin.createTumblrPost(tumblrPost, function(err, document) {
                if (err) {
                  return complete(err);
                }
                if (document != null) {
                  ++imported;
                  docpad.log('debug', "Imported  tumblr post " + i + "/" + tumblrPosts.length + ": " + (document.getFilePath()));
                } else {
                  docpad.log('debug', "Skipped   tumblr post " + i + "/" + tumblrPosts.length);
                }
                return complete();
              });
            });
          });
          return tasks.run();
        });
        return this;
      };

      return TumblrPlugin;

    })(BasePlugin);
    /*
    	writeFiles: (opts,next) ->
    		if @getConfig().writeSourcEfiles
    			.writeSource()
    */

  };

}).call(this);
